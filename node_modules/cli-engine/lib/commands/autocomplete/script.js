'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _ = require('.');

var _2 = _interopRequireDefault(_);

var _output = require('cli-engine-command/lib/output');

var _output2 = _interopRequireDefault(_output);

require('cli-engine-config');

var _fsExtra = require('fs-extra');

var _fsExtra2 = _interopRequireDefault(_fsExtra);

var _plugins = require('../../plugins');

var _plugins2 = _interopRequireDefault(_plugins);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class AutocompleteScript extends _2.default {
  // hide until beta release
  async run() {
    this.errorIfWindows();
    await AutocompleteScript.generateAutocompleteCommands(this);

    const shell = this.argv[0] || this.config.shell;
    if (!shell) {
      this.out.error('Error: Missing required argument shell');
    }

    switch (shell) {
      case 'zsh':
        this.out.log(`fpath=(
  ${_path2.default.join(this.functionsPath, 'zsh')}
  $fpath
);
autoload -Uz compinit;
compinit;`);
        break;
      default:
        this.out.error(`Currently ${shell} is not a supported shell for autocomplete`);
    }
  }

  static async generateAutocompleteCommands({ config, out }) {
    const flatten = require('lodash.flatten');
    try {
      // TODO: move from cli to client dir if not already present
      // if (!fs.pathExistsSync(path.join(this.config.dataDir, 'client', 'autocomplete', 'bash', 'heroku'))) {
      //   const cli = path.join(this.config.dataDir, 'cli', 'autocomplete')
      //   const client = path.join(this.config.dataDir, 'client', 'autocomplete')
      //   fs.copySync(cli, client)
      // }
      const plugins = await new _plugins2.default(out).list();
      const cmds = plugins.map(p => p.commands.filter(c => !c.hidden).map(c => {
        let publicFlags = Object.keys(c.flags).filter(flag => !c.flags[flag].hidden).map(flag => `--${flag}`).join(' ');
        let flags = publicFlags.length ? ` ${publicFlags}` : '';
        let namespace = p.namespace ? `${p.namespace}:` : '';
        return `${namespace}${c.id}${flags}`;
      }));
      const commands = flatten(cmds).join('\n');
      _fsExtra2.default.writeFileSync(_path2.default.join(config.dataDir, 'client', 'node_modules', 'cli-engine', 'autocomplete', 'commands'), commands);
    } catch (e) {
      out.debug('Error creating autocomplete commands');
      out.debug(e.message);
    }
  }
}
exports.default = AutocompleteScript;
AutocompleteScript.topic = 'autocomplete';
AutocompleteScript.command = 'script';
AutocompleteScript.description = 'outputs autocomplete config script for shells';
AutocompleteScript.hidden = true;
AutocompleteScript.args = [{ name: 'shell', description: 'shell type', required: false }];